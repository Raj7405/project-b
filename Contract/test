const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("DecentReferral (MVP flows with Re-Topup Eligibility)", function () {
  let Token, token;
  let Ref, ref;
  let owner, company, alice, bob, carol, dave, eve, frank;

  beforeEach(async function () {
    [owner, company, alice, bob, carol, dave, eve, frank] = await ethers.getSigners();
    
    // Deploy a simple ERC20
    const ERC20 = await ethers.getContractFactory("ERC20Mock");
    token = await ERC20.deploy("MockToken", "MTK", owner.address, ethers.parseUnits("1000000", 18));
    await token.waitForDeployment();

    // Transfer some tokens to users
    await token.transfer(alice.address, ethers.parseUnits("1000", 18));
    await token.transfer(bob.address, ethers.parseUnits("1000", 18));
    await token.transfer(carol.address, ethers.parseUnits("1000", 18));
    await token.transfer(dave.address, ethers.parseUnits("1000", 18));
    await token.transfer(eve.address, ethers.parseUnits("1000", 18));
    await token.transfer(frank.address, ethers.parseUnits("1000", 18));

    // Deploy Ref contract
    Ref = await ethers.getContractFactory("DecentReferral");
    const packageAmount = ethers.parseUnits("20", 18);
    const reTopupAmount = ethers.parseUnits("40", 18);
    ref = await Ref.deploy(token.target, company.address, packageAmount, reTopupAmount);
    await ref.waitForDeployment();

    // Fund contract with some token balance for safety (owner sends)
    await token.transfer(ref.target, ethers.parseUnits("1000", 18));
  });

  describe("Registration Flow", function() {
    it("should register user under company and pay direct income", async function () {
      // Alice registers under company (company is id=1)
      const companyBalBefore = await token.balanceOf(company.address);
      
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      
      const aliceId = await ref.getUserId(alice.address);
      expect(aliceId).to.equal(2); // Company is 1, Alice is 2

      const companyBalAfter = await token.balanceOf(company.address);
      // Company receives both parent income ($18) and company fee ($2) = $20 total
      // because Alice registered under company, so company is both parent and fee recipient
      expect(companyBalAfter - companyBalBefore).to.equal(ethers.parseUnits("20", 18));
    });

    it("should send first sponsor income to parent ($18) and company fee ($2)", async function () {
      // Alice registers under company
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      const aliceId = await ref.getUserId(alice.address);

      const aliceBalBefore = await token.balanceOf(alice.address);
      const companyBalBefore = await token.balanceOf(company.address);

      // Bob registers under Alice (first sponsor)
      await token.connect(bob).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(bob).register(aliceId);

      const aliceBalAfter = await token.balanceOf(alice.address);
      const companyBalAfter = await token.balanceOf(company.address);

      // Alice should receive $18
      expect(aliceBalAfter - aliceBalBefore).to.equal(ethers.parseUnits("18", 18));
      // Company should receive $2
      expect(companyBalAfter - companyBalBefore).to.equal(ethers.parseUnits("2", 18));

      // Check sponsor count
      const [, , sponsorCnt, ,] = await ref.userInfo(aliceId);
      expect(sponsorCnt).to.equal(1);
    });

    it("should send parent (Alice) to Auto Pool when they get second sponsor", async function () {
      // Alice registers under company
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      const aliceId = await ref.getUserId(alice.address);

      // Bob registers under Alice (first sponsor)
      await token.connect(bob).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(bob).register(aliceId);

      const aliceBalBefore = await token.balanceOf(alice.address);
      const companyBalBefore = await token.balanceOf(company.address);
      const poolNodesBefore = await ref.getPoolNodesCount(); // Use poolNodes count instead of queue

      // Carol registers under Alice (second sponsor - ALICE goes to Auto Pool, not Carol)
      await token.connect(carol).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(carol).register(aliceId);

      const aliceBalAfter = await token.balanceOf(alice.address);
      const companyBalAfter = await token.balanceOf(company.address);
      const poolNodesAfter = await ref.getPoolNodesCount();

      // Alice SHOULD receive $18 (payment still happens normally)
      expect(aliceBalAfter - aliceBalBefore).to.equal(ethers.parseUnits("18", 18));
      // Company SHOULD receive $2 fee (payment happens normally)
      expect(companyBalAfter - companyBalBefore).to.equal(ethers.parseUnits("2", 18));
      // Pool nodes should increase (Alice entered and was placed in the pool)
      // Note: _tryProcessPool() is called automatically, so Alice is immediately placed
      expect(poolNodesAfter).to.be.gt(poolNodesBefore);

      // Check sponsor count
      const [, , sponsorCnt, ,] = await ref.userInfo(aliceId);
      expect(sponsorCnt).to.equal(2);
    });

    it("should pay third sponsor normally again ($18 + $2)", async function () {
      // Setup: Alice with 2 sponsors (Bob and Carol)
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      const aliceId = await ref.getUserId(alice.address);

      await token.connect(bob).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(bob).register(aliceId);

      await token.connect(carol).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(carol).register(aliceId);

      const aliceBalBefore = await token.balanceOf(alice.address);
      const companyBalBefore = await token.balanceOf(company.address);

      // Dave registers under Alice (third sponsor - normal payment)
      await token.connect(dave).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(dave).register(aliceId);

      const aliceBalAfter = await token.balanceOf(alice.address);
      const companyBalAfter = await token.balanceOf(company.address);

      // Alice should receive $18
      expect(aliceBalAfter - aliceBalBefore).to.equal(ethers.parseUnits("18", 18));
      // Company should receive $2
      expect(companyBalAfter - companyBalBefore).to.equal(ethers.parseUnits("2", 18));

      const [, , sponsorCnt, ,] = await ref.userInfo(aliceId);
      expect(sponsorCnt).to.equal(3);
    });
  });

  describe("Re-Topup Eligibility Logic", function() {
    beforeEach(async function() {
      // Build chain: Company(1) -> Alice(2) -> Bob(3) -> Carol(4) -> Dave(5)
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);

      const aliceId = await ref.getUserId(alice.address);
      await token.connect(bob).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(bob).register(aliceId);

      const bobId = await ref.getUserId(bob.address);
      await token.connect(carol).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(carol).register(bobId);

      const carolId = await ref.getUserId(carol.address);
      await token.connect(dave).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(dave).register(carolId);
    });

    it("should mark user as eligible after re-topup", async function() {
      const aliceId = await ref.getUserId(alice.address);
      
      // Before re-topup
      expect(await ref.isEligibleForReTopupIncome(aliceId)).to.be.false;
      
      // Do re-topup
      await token.connect(alice).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(alice).reTopup();
      
      // After re-topup
      expect(await ref.isEligibleForReTopupIncome(aliceId)).to.be.true;
    });

    it("should distribute re-topup income only to eligible ancestors", async function() {
      // Setup: Only Alice and Dave will re-topup (Bob and Carol will NOT)
      // Chain: Company -> Alice(eligible) -> Bob(not eligible) -> Carol(not eligible) -> Dave(will re-topup)
      
      const aliceId = await ref.getUserId(alice.address);
      const bobId = await ref.getUserId(bob.address);
      const carolId = await ref.getUserId(carol.address);
      const daveId = await ref.getUserId(dave.address);

      // Alice re-tops up first
      await token.connect(alice).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(alice).reTopup();

      // Capture balances before Dave's re-topup
      const aliceBalBefore = await token.balanceOf(alice.address);
      const bobBalBefore = await token.balanceOf(bob.address);
      const carolBalBefore = await token.balanceOf(carol.address);
      const companyBalBefore = await token.balanceOf(company.address);

      // Dave re-tops up
      // Expected distribution:
      // Level 1 (30% of $36 = $10.80) -> Carol (not eligible) -> goes to company
      // Level 2 (15% of $36 = $5.40) -> Bob (not eligible) -> goes to company
      // Level 3 (10% of $36 = $3.60) -> Alice (eligible) -> goes to Alice
      // Level 4 onwards would go to Company (reached root)
      await token.connect(dave).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(dave).reTopup();

      const aliceBalAfter = await token.balanceOf(alice.address);
      const bobBalAfter = await token.balanceOf(bob.address);
      const carolBalAfter = await token.balanceOf(carol.address);
      const companyBalAfter = await token.balanceOf(company.address);

      // Carol should NOT receive anything (not eligible)
      expect(carolBalAfter).to.equal(carolBalBefore);
      
      // Bob should NOT receive anything (not eligible)
      expect(bobBalAfter).to.equal(bobBalBefore);
      
      // Alice should receive Level 3 share: 10% of $36 = $3.60
      expect(aliceBalAfter - aliceBalBefore).to.equal(ethers.parseUnits("3.6", 18));
      
      // Company should receive:
      // - Level 1 share ($10.80) + Level 2 share ($5.40) + Level 4-10 shares + $4 company fee
      // Level 4: 5% = $1.80, L5-L8: 4*5% = $7.20, L9-L10: 2*10% = $7.20
      // Ineligible shares: $10.80 + $5.40 = $16.20
      // Root shares (L4-L10): $1.80 + $1.80 + $1.80 + $1.80 + $1.80 + $3.60 + $3.60 = $16.20
      // Company fee: $4.00
      // Total: $16.20 + $16.20 + $4.00 = $36.40
      const companyGain = companyBalAfter - companyBalBefore;
      expect(companyGain).to.equal(ethers.parseUnits("36.4", 18));
    });

    it("should distribute full re-topup when all ancestors are eligible", async function() {
      // Make everyone eligible by having them all re-topup first
      const aliceId = await ref.getUserId(alice.address);
      const bobId = await ref.getUserId(bob.address);
      const carolId = await ref.getUserId(carol.address);

      await token.connect(alice).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(alice).reTopup();

      await token.connect(bob).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(bob).reTopup();

      await token.connect(carol).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(carol).reTopup();

      // Capture balances
      const aliceBalBefore = await token.balanceOf(alice.address);
      const bobBalBefore = await token.balanceOf(bob.address);
      const carolBalBefore = await token.balanceOf(carol.address);
      const companyBalBefore = await token.balanceOf(company.address);

      // Dave re-tops up
      await token.connect(dave).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(dave).reTopup();

      const aliceBalAfter = await token.balanceOf(alice.address);
      const bobBalAfter = await token.balanceOf(bob.address);
      const carolBalAfter = await token.balanceOf(carol.address);
      const companyBalAfter = await token.balanceOf(company.address);

      // Carol should receive Level 1: 30% of $36 = $10.80
      expect(carolBalAfter - carolBalBefore).to.equal(ethers.parseUnits("10.8", 18));
      
      // Bob should receive Level 2: 15% of $36 = $5.40
      expect(bobBalAfter - bobBalBefore).to.equal(ethers.parseUnits("5.4", 18));
      
      // Alice should receive Level 3: 10% of $36 = $3.60
      expect(aliceBalAfter - aliceBalBefore).to.equal(ethers.parseUnits("3.6", 18));
      
      // Company receives Level 4-10 + $4 fee
      // L4-L8: 5*5% = $9.00, L9-L10: 2*10% = $7.20, Total: $16.20 + $4 = $20.20
      const companyGain = companyBalAfter - companyBalBefore;
      expect(companyGain).to.equal(ethers.parseUnits("20.2", 18));
    });

    it("should send all shares to company when no ancestors are eligible", async function() {
      // Dave re-tops up without anyone else re-topping up
      const companyBalBefore = await token.balanceOf(company.address);

      await token.connect(dave).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(dave).reTopup();

      const companyBalAfter = await token.balanceOf(company.address);

      // Company should receive all $36 distributable + $4 fee = $40
      expect(companyBalAfter - companyBalBefore).to.equal(ethers.parseUnits("40", 18));
    });
  });

  describe("View Functions", function() {
    it("should return correct user info including re-topup status", async function() {
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      const aliceId = await ref.getUserId(alice.address);

      let [wallet, parentId, sponsorCnt, exists, hasReTopup] = await ref.userInfo(aliceId);
      expect(wallet).to.equal(alice.address);
      expect(parentId).to.equal(1);
      expect(sponsorCnt).to.equal(0);
      expect(exists).to.be.true;
      expect(hasReTopup).to.be.false;

      // Do re-topup
      await token.connect(alice).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(alice).reTopup();

      [wallet, parentId, sponsorCnt, exists, hasReTopup] = await ref.userInfo(aliceId);
      expect(hasReTopup).to.be.true;
    });

    it("should check eligibility by wallet address", async function() {
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);

      expect(await ref.isEligibleForReTopupIncomeByWallet(alice.address)).to.be.false;

      await token.connect(alice).approve(ref.target, ethers.parseUnits("40", 18));
      await ref.connect(alice).reTopup();

      expect(await ref.isEligibleForReTopupIncomeByWallet(alice.address)).to.be.true;
    });
  });

  describe("Admin Functions", function() {
    it("should allow owner to pause and unpause", async function() {
      await ref.pause();
      
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await expect(
        ref.connect(alice).register(1)
      ).to.be.revertedWith("Pausable: paused");

      await ref.unpause();
      await ref.connect(alice).register(1); // Should succeed
    });

    it("should allow owner to emergency withdraw", async function() {
      const contractBalBefore = await token.balanceOf(ref.target);
      const ownerBalBefore = await token.balanceOf(owner.address);

      const withdrawAmount = ethers.parseUnits("100", 18);
      await ref.emergencyWithdraw(owner.address, withdrawAmount);

      const contractBalAfter = await token.balanceOf(ref.target);
      const ownerBalAfter = await token.balanceOf(owner.address);

      expect(contractBalBefore - contractBalAfter).to.equal(withdrawAmount);
      expect(ownerBalAfter - ownerBalBefore).to.equal(withdrawAmount);
    });

    it("should allow owner to update company wallet", async function() {
      const newCompany = eve.address;
      await ref.setCompanyWallet(newCompany);
      expect(await ref.companyWallet()).to.equal(newCompany);
    });
  });

  describe("Auto Pool", function() {
    it("should place parent into auto pool queue when they get 2nd sponsor", async function() {
      // Setup multiple users to trigger pool placements
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      const aliceId = await ref.getUserId(alice.address);

      // Add first sponsor - Alice does not go to pool yet
      await token.connect(bob).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(bob).register(aliceId);

      const poolNodesBefore = await ref.getPoolNodesCount();

      // Add second sponsor - Alice (the parent) goes to pool
      await token.connect(carol).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(carol).register(aliceId);

      const poolNodesAfter = await ref.getPoolNodesCount();
      expect(poolNodesAfter).to.be.gt(poolNodesBefore);
    });

    it("should correctly identify which user enters the pool", async function() {
      // Company -> Alice -> Bob, Carol (Bob and Carol are Alice's sponsors)
      await token.connect(alice).approve(ref.target, ethers.parseUnits("20", 18));
      await ref.connect(alice).register(1);
      const aliceId = await ref.getUserId(alice.address);

      // First sponsor
      await token.connect(bob).approve(ref.target, ethers.parseUnits("20", 18));
      const tx1 = await ref.connect(bob).register(aliceId);
      const receipt1 = await tx1.wait();
      
      // Check no AutoPoolEnqueued event yet
      const poolEvents1 = receipt1.logs.filter(log => {
        try {
          const parsed = ref.interface.parseLog(log);
          return parsed.name === "AutoPoolEnqueued";
        } catch { return false; }
      });
      expect(poolEvents1.length).to.equal(0);

      // Second sponsor - should trigger Alice to enter pool
      await token.connect(carol).approve(ref.target, ethers.parseUnits("20", 18));
      const tx2 = await ref.connect(carol).register(aliceId);
      const receipt2 = await tx2.wait();
      
      // Check AutoPoolEnqueued event exists and it's Alice (not Carol)
      const poolEvents2 = receipt2.logs.filter(log => {
        try {
          const parsed = ref.interface.parseLog(log);
          return parsed.name === "AutoPoolEnqueued";
        } catch { return false; }
      });
      expect(poolEvents2.length).to.equal(1);
      
      const parsedEvent = ref.interface.parseLog(poolEvents2[0]);
      expect(parsedEvent.args.id).to.equal(aliceId); // Alice's ID, not Carol's
      expect(parsedEvent.args.wallet).to.equal(alice.address); // Alice's address
    });
  });
});

